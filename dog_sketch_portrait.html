<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PAWTRAITS — Dog Sketch Studio</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --cream: #f5f0e8;
    --ink: #1a1410;
    --warm-gray: #8c8075;
    --accent: #c4622d;
    --paper: #faf7f2;
    --border: #d4c9b8;
  }

  html, body { height: 100%; background: var(--cream); color: var(--ink); font-family: 'DM Mono', monospace; }

  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
    pointer-events: none; z-index: 100; opacity: 0.4;
  }

  .page { min-height: 100vh; display: flex; flex-direction: column; }

  header {
    padding: 1.5rem 3rem;
    display: flex; align-items: baseline; gap: 1.5rem;
    border-bottom: 1px solid var(--border);
  }
  .logo { font-family: 'Playfair Display', serif; font-size: 2rem; font-weight: 700; letter-spacing: -0.02em; }
  .logo span { color: var(--accent); font-style: italic; }
  .tagline { font-size: 0.65rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--warm-gray); }

  main {
    flex: 1;
    display: grid; grid-template-columns: 1fr 1fr; gap: 3rem;
    max-width: 1400px; margin: 0 auto; width: 100%; padding: 3rem;
  }

  .panel {
    background: var(--paper); border: 1px solid var(--border);
    border-radius: 2px; overflow: hidden; display: flex; flex-direction: column;
  }
  .panel-header {
    padding: 1rem 1.5rem; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 0.75rem;
  }
  .panel-num { font-size: 0.6rem; letter-spacing: 0.2em; color: var(--accent); text-transform: uppercase; }
  .panel-title { font-family: 'Playfair Display', serif; font-size: 1rem; font-weight: 400; }

  .panel-body {
    flex: 1; padding: 1.5rem;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-height: 420px; position: relative;
  }

  /* ── UPLOAD ZONE ── */
  .upload-zone {
    width: 100%; min-height: 360px;
    border: 2px dashed var(--border); border-radius: 2px;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 1rem; cursor: pointer; transition: all 0.2s ease; position: relative;
  }
  .upload-zone:hover, .upload-zone.dragover { border-color: var(--accent); background: rgba(196,98,45,0.03); }
  .upload-zone input[type="file"] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
  .upload-icon { width: 56px; height: 56px; opacity: 0.3; }
  .upload-label { font-size: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; color: var(--warm-gray); text-align: center; line-height: 1.8; }
  .upload-sub { font-size: 0.6rem; color: var(--border); letter-spacing: 0.08em; }

  /* ── CROP UI ── */
  .crop-wrapper {
    width: 100%;
    display: flex; flex-direction: column; align-items: center; gap: 0.5rem;
  }

  .crop-hint {
    font-size: 0.58rem; letter-spacing: 0.12em; text-transform: uppercase;
    color: var(--warm-gray); opacity: 0.7;
  }

  /* The container that holds img + overlays, sized to match rendered image */
  .crop-container {
    position: relative;
    display: inline-block; /* shrink-wrap to image */
    line-height: 0;
    cursor: default;
    user-select: none;
  }

  .crop-container img {
    display: block;
    max-width: 100%;
    max-height: 360px;
    object-fit: contain;
    pointer-events: none;
  }

  /* Dark shades outside crop */
  .shade {
    position: absolute;
    background: rgba(26,20,16,0.5);
    pointer-events: none;
    z-index: 1;
  }

  /* Bright crop border */
  .crop-border {
    position: absolute;
    border: 1.5px solid rgba(196,98,45,0.85);
    pointer-events: none;
    z-index: 3;
  }

  /* Corner accents */
  .crop-corner {
    position: absolute; width: 12px; height: 12px;
    border-color: var(--accent); border-style: solid;
    pointer-events: none; z-index: 4;
  }
  .crop-corner.tl { top: -1.5px; left: -1.5px; border-width: 2.5px 0 0 2.5px; }
  .crop-corner.tr { top: -1.5px; right: -1.5px; border-width: 2.5px 2.5px 0 0; }
  .crop-corner.bl { bottom: -1.5px; left: -1.5px; border-width: 0 0 2.5px 2.5px; }
  .crop-corner.br { bottom: -1.5px; right: -1.5px; border-width: 0 2.5px 2.5px 0; }

  /* ── DRAGGABLE HANDLE PILLS ── */
  .handle {
    position: absolute;
    z-index: 5;
    display: flex; align-items: center; justify-content: center;
  }

  /* Top / Bottom: horizontal pill, spans crop width, sits on edge */
  .handle.h {
    left: 0; right: 0; height: 0;
    cursor: ns-resize;
  }
  /* Left / Right: vertical pill, spans crop height, sits on edge */
  .handle.v {
    top: 0; bottom: 0; width: 0;
    cursor: ew-resize;
  }

  .pill {
    background: #fff;
    border: 1.5px solid rgba(196,98,45,0.75);
    border-radius: 999px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    display: flex; align-items: center; justify-content: center; gap: 2.5px;
    pointer-events: all;
    transition: box-shadow 0.15s, border-color 0.15s;
  }
  .pill:hover { box-shadow: 0 2px 12px rgba(196,98,45,0.4); border-color: var(--accent); }
  .handle.h .pill { width: 40px; height: 14px; flex-direction: row; }
  .handle.v .pill { width: 14px; height: 40px; flex-direction: column; }
  .dot { width: 3.5px; height: 3.5px; border-radius: 50%; background: var(--accent); opacity: 0.65; }

  .change-btn {
    margin-top: 0.4rem;
    align-self: flex-end;
    background: var(--ink); color: var(--cream); border: none;
    padding: 0.3rem 0.7rem;
    font-family: 'DM Mono', monospace; font-size: 0.58rem;
    letter-spacing: 0.1em; text-transform: uppercase; cursor: pointer;
    opacity: 0.55; transition: opacity 0.2s;
  }
  .change-btn:hover { opacity: 1; }

  /* ── SETTINGS ── */
  .settings-row {
    padding: 0.75rem 1.5rem; border-top: 1px solid var(--border);
    display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;
  }
  .setting-group { display: flex; align-items: center; gap: 0.5rem; }
  .setting-label { font-size: 0.6rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--warm-gray); }
  .setting-input {
    background: transparent; border: 1px solid var(--border); color: var(--ink);
    font-family: 'DM Mono', monospace; font-size: 0.65rem; padding: 0.25rem 0.5rem;
    width: 70px; outline: none;
  }
  .setting-input:focus { border-color: var(--accent); }

  /* ── PROCESS BTN ── */
  .process-section {
    padding: 1.5rem 3rem; display: flex; align-items: center; justify-content: center;
    border-top: 1px solid var(--border);
  }
  .process-btn {
    background: var(--ink); color: var(--cream); border: none;
    padding: 1rem 3rem;
    font-family: 'Playfair Display', serif; font-size: 1rem; font-style: italic;
    letter-spacing: 0.05em; cursor: pointer; transition: all 0.25s ease;
    position: relative; overflow: hidden;
  }
  .process-btn::before {
    content: ''; position: absolute; inset: 0;
    background: var(--accent); transform: translateX(-100%); transition: transform 0.3s ease;
  }
  .process-btn:hover::before { transform: translateX(0); }
  .process-btn span { position: relative; z-index: 1; }
  .process-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .process-btn:disabled::before { display: none; }

  /* ── OUTPUT ── */
  .output-placeholder { display: flex; flex-direction: column; align-items: center; gap: 1rem; opacity: 0.3; }
  .sketch-preview-lines { width: 120px; height: 120px; }
  .output-label { font-size: 0.65rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--warm-gray); }
  .progress-wrap { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; width: 100%; }
  .progress-text { font-size: 0.7rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--warm-gray); }
  .progress-bar-outer { width: 200px; height: 2px; background: var(--border); overflow: hidden; }
  .progress-bar-inner { height: 100%; background: var(--accent); width: 0%; transition: width 0.4s ease; }
  .sketch-result { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 1.5rem; animation: fadeIn 0.6s ease; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
  .sketch-img { max-width: 100%; max-height: 340px; object-fit: contain; border: 1px solid var(--border); box-shadow: 4px 4px 0 var(--border); }
  .download-btn {
    background: transparent; color: var(--accent); border: 1px solid var(--accent);
    padding: 0.6rem 1.5rem; font-family: 'DM Mono', monospace; font-size: 0.65rem;
    letter-spacing: 0.15em; text-transform: uppercase; cursor: pointer;
    text-decoration: none; display: inline-block; transition: all 0.2s;
  }
  .download-btn:hover { background: var(--accent); color: white; }

  footer {
    padding: 1rem 3rem; border-top: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
  }
  .footer-note { font-size: 0.6rem; letter-spacing: 0.1em; color: var(--border); text-transform: uppercase; }

  #workCanvas, #outputCanvas { display: none; }

  @media (max-width: 900px) {
    main { grid-template-columns: 1fr; padding: 1.5rem; gap: 1.5rem; }
    header { padding: 1.5rem; }
  }
</style>
</head>
<body>
<div class="page">

  <header>
    <div class="logo">Paw<span>traits</span></div>
    <div class="tagline">Dog Portrait Sketch Studio</div>
  </header>

  <main>
    <!-- INPUT PANEL -->
    <div class="panel">
      <div class="panel-header">
        <span class="panel-num">01</span>
        <span class="panel-title">Upload &amp; Frame the Face</span>
      </div>
      <div class="panel-body" id="inputBody">
        <div class="upload-zone" id="uploadZone">
          <input type="file" accept="image/jpeg,image/jpg,image/png" id="fileInput">
          <svg class="upload-icon" viewBox="0 0 64 64" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="8" y="16" width="48" height="36" rx="2"/>
            <circle cx="32" cy="34" r="10"/><circle cx="32" cy="34" r="4"/>
            <path d="M24 16l4-8h8l4 8"/>
          </svg>
          <div class="upload-label">Drop a photo here<br>or click to browse</div>
          <div class="upload-sub">JPEG / JPG / PNG · Any size</div>
        </div>
      </div>
      <div class="settings-row">
        <div class="setting-group">
          <span class="setting-label">Contrast</span>
          <input class="setting-input" type="number" id="contrast" value="1.5" min="1" max="3" step="0.1">
        </div>
        <div class="setting-group">
          <span class="setting-label">Blur radius</span>
          <input class="setting-input" type="number" id="blurRadius" value="21" min="5" max="51" step="2">
        </div>
      </div>
    </div>

    <!-- OUTPUT PANEL -->
    <div class="panel">
      <div class="panel-header">
        <span class="panel-num">02</span>
        <span class="panel-title">Sketched Portrait</span>
      </div>
      <div class="panel-body" id="outputBody">
        <div class="output-placeholder" id="outputPlaceholder">
          <svg class="sketch-preview-lines" viewBox="0 0 120 120" fill="none" stroke="currentColor" stroke-width="1">
            <ellipse cx="60" cy="60" rx="50" ry="50"/>
            <ellipse cx="60" cy="60" rx="35" ry="38"/>
            <circle cx="45" cy="50" r="5"/><circle cx="75" cy="50" r="5"/>
            <ellipse cx="60" cy="68" rx="8" ry="5"/>
            <path d="M50 80 Q60 88 70 80"/>
            <path d="M20 45 Q15 35 25 30"/><path d="M100 45 Q105 35 95 30"/>
          </svg>
          <span class="output-label">Awaiting photo</span>
        </div>
      </div>
    </div>
  </main>

  <div class="process-section">
    <button class="process-btn" id="processBtn" disabled>
      <span>Sketch Portrait →</span>
    </button>
  </div>

  <footer>
    <span class="footer-note">All processing happens in your browser — no data leaves your device</span>
    <span class="footer-note">Pawtraits © 2026</span>
  </footer>
</div>

<canvas id="workCanvas"></canvas>
<canvas id="outputCanvas"></canvas>

<script>
// ── STATE ──
let originalImage = null;
// crop fractions relative to the natural image (0..1)
let crop = { top: 0.10, left: 0.10, bottom: 0.90, right: 0.90 };
const MIN_SIZE = 0.08;

// ── UPLOAD ──
setupUploadZone();

function setupUploadZone() {
  const zone = document.getElementById('uploadZone');
  const input = document.getElementById('fileInput');
  if (!zone || !input) return;
  zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('dragover'); });
  zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
  zone.addEventListener('drop', e => {
    e.preventDefault(); zone.classList.remove('dragover');
    if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
  });
  input.addEventListener('change', e => { if (e.target.files[0]) loadImage(e.target.files[0]); });
}

function loadImage(file) {
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      originalImage = img;
      crop = { top: 0.10, left: 0.10, bottom: 0.90, right: 0.90 };
      buildCropUI(ev.target.result);
      document.getElementById('processBtn').disabled = false;
      resetOutput();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
}

function resetOutput() {
  document.getElementById('outputPlaceholder').style.display = 'flex';
  const ex = document.getElementById('sketchResult');
  if (ex) ex.remove();
}

// ── BUILD CROP UI ──
function buildCropUI(src) {
  const inputBody = document.getElementById('inputBody');
  inputBody.innerHTML = `
    <div class="crop-wrapper" id="cropWrapper">
      <span class="crop-hint">Drag the handles to frame the face</span>
      <div class="crop-container" id="cropContainer">
        <img id="cropImg" src="${src}" alt="Your dog" draggable="false">
        <!-- shades (4 regions outside crop box) -->
        <div class="shade" id="shT"></div>
        <div class="shade" id="shB"></div>
        <div class="shade" id="shL"></div>
        <div class="shade" id="shR"></div>
        <!-- crop border box -->
        <div class="crop-border" id="cropBorder">
          <div class="crop-corner tl"></div>
          <div class="crop-corner tr"></div>
          <div class="crop-corner bl"></div>
          <div class="crop-corner br"></div>
        </div>
        <!-- 4 draggable handles -->
        <div class="handle h" id="hTop" data-edge="top">
          <div class="pill"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        </div>
        <div class="handle h" id="hBot" data-edge="bottom">
          <div class="pill"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        </div>
        <div class="handle v" id="hLeft" data-edge="left">
          <div class="pill"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        </div>
        <div class="handle v" id="hRight" data-edge="right">
          <div class="pill"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        </div>
      </div>
      <button class="change-btn" id="changeBtn">Change photo</button>
    </div>
  `;

  document.getElementById('changeBtn').addEventListener('click', resetUpload);

  const imgEl = document.getElementById('cropImg');

  const doUpdate = () => updateOverlay(imgEl);
  imgEl.addEventListener('load', doUpdate);
  if (imgEl.complete) doUpdate();

  // Re-render on window resize
  window.addEventListener('resize', doUpdate);

  // Attach handle drags
  ['hTop','hBot','hLeft','hRight'].forEach(id => {
    const el = document.getElementById(id);
    const edge = el.dataset.edge;
    makeDraggable(el, edge, imgEl);
  });
}

function getImgRect(imgEl) {
  // Returns position of rendered image relative to its .crop-container parent
  const container = document.getElementById('cropContainer');
  const ir = imgEl.getBoundingClientRect();
  const cr = container.getBoundingClientRect();
  return { x: ir.left - cr.left, y: ir.top - cr.top, w: ir.width, h: ir.height };
}

function updateOverlay(imgEl) {
  const r = getImgRect(imgEl);
  if (!r || r.w === 0) return;

  // Pixel coords of crop edges within the container
  const T = r.y + crop.top    * r.h;
  const B = r.y + crop.bottom * r.h;
  const L = r.x + crop.left   * r.w;
  const R = r.x + crop.right  * r.w;

  // Container total size
  const container = document.getElementById('cropContainer');
  const cw = container.offsetWidth;
  const ch = container.offsetHeight;

  // Shades
  s('shT', { top: 0,   left: 0,   width: cw,    height: T      });
  s('shB', { top: B,   left: 0,   width: cw,    height: ch - B });
  s('shL', { top: T,   left: 0,   width: L,     height: B - T  });
  s('shR', { top: T,   left: R,   width: cw - R,height: B - T  });

  // Crop border
  const brd = document.getElementById('cropBorder');
  brd.style.cssText = `top:${T}px;left:${L}px;width:${R-L}px;height:${B-T}px;`;

  // Handles — centered on each edge line
  const hT = document.getElementById('hTop');
  hT.style.cssText = `top:${T}px; left:${L}px; right:${cw-R}px; height:0; transform:translateY(-50%);`;

  const hB = document.getElementById('hBot');
  hB.style.cssText = `top:${B}px; left:${L}px; right:${cw-R}px; height:0; transform:translateY(-50%);`;

  const hL = document.getElementById('hLeft');
  hL.style.cssText = `left:${L}px; top:${T}px; bottom:${ch-B}px; width:0; transform:translateX(-50%);`;

  const hR = document.getElementById('hRight');
  hR.style.cssText = `left:${R}px; top:${T}px; bottom:${ch-B}px; width:0; transform:translateX(-50%);`;
}

function s(id, p) {
  const el = document.getElementById(id);
  if (!el) return;
  el.style.cssText = `top:${p.top}px;left:${p.left}px;width:${p.width}px;height:${p.height}px;`;
}

// ── DRAGGABLE HANDLES ──
function makeDraggable(el, edge, imgEl) {
  let startPx = 0, startFrac = 0;

  const isH = edge === 'top' || edge === 'bottom'; // horizontal drag axis

  const onStart = e => {
    e.preventDefault(); e.stopPropagation();
    const pt = e.touches ? e.touches[0] : e;
    startPx = isH ? pt.clientY : pt.clientX;
    startFrac = crop[edge];
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onEnd);
    document.addEventListener('touchmove', onMove, { passive: false });
    document.addEventListener('touchend', onEnd);
  };

  const onMove = e => {
    e.preventDefault();
    const pt = e.touches ? e.touches[0] : e;
    const nowPx = isH ? pt.clientY : pt.clientX;
    const delta = nowPx - startPx;

    const r = getImgRect(imgEl);
    const dim = isH ? r.h : r.w;
    if (dim === 0) return;

    let newFrac = startFrac + delta / dim;

    // Clamp to [0,1] and maintain minimum crop size
    if (edge === 'top')    newFrac = Math.max(0, Math.min(crop.bottom - MIN_SIZE, newFrac));
    if (edge === 'bottom') newFrac = Math.min(1, Math.max(crop.top    + MIN_SIZE, newFrac));
    if (edge === 'left')   newFrac = Math.max(0, Math.min(crop.right  - MIN_SIZE, newFrac));
    if (edge === 'right')  newFrac = Math.min(1, Math.max(crop.left   + MIN_SIZE, newFrac));

    crop[edge] = newFrac;
    updateOverlay(imgEl);
  };

  const onEnd = () => {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onEnd);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('touchend', onEnd);
  };

  el.addEventListener('mousedown', onStart);
  el.addEventListener('touchstart', onStart, { passive: false });
}

function resetUpload() {
  window.removeEventListener('resize', () => {});
  originalImage = null;
  crop = { top: 0.10, left: 0.10, bottom: 0.90, right: 0.90 };
  document.getElementById('processBtn').disabled = true;
  resetOutput();
  document.getElementById('inputBody').innerHTML = `
    <div class="upload-zone" id="uploadZone">
      <input type="file" accept="image/jpeg,image/jpg,image/png" id="fileInput">
      <svg class="upload-icon" viewBox="0 0 64 64" fill="none" stroke="currentColor" stroke-width="1.5">
        <rect x="8" y="16" width="48" height="36" rx="2"/>
        <circle cx="32" cy="34" r="10"/><circle cx="32" cy="34" r="4"/>
        <path d="M24 16l4-8h8l4 8"/>
      </svg>
      <div class="upload-label">Drop a photo here<br>or click to browse</div>
      <div class="upload-sub">JPEG / JPG / PNG · Any size</div>
    </div>
  `;
  setupUploadZone();
}

// ── SKETCH PROCESS ──
document.getElementById('processBtn').addEventListener('click', () => {
  if (!originalImage) return;
  document.getElementById('processBtn').disabled = true;

  const ob = document.getElementById('outputBody');
  document.getElementById('outputPlaceholder').style.display = 'none';
  const ex = document.getElementById('sketchResult'); if (ex) ex.remove();

  const prog = document.createElement('div');
  prog.id = 'progressWrap'; prog.className = 'progress-wrap';
  prog.innerHTML = `<span class="progress-text">Rendering sketch…</span>
    <div class="progress-bar-outer"><div class="progress-bar-inner" id="progressBar"></div></div>`;
  ob.appendChild(prog);
  setTimeout(() => { const b = document.getElementById('progressBar'); if (b) b.style.width = '80%'; }, 80);

  setTimeout(() => {
    try {
      const result = generateSketch();
      showSketchResult(result);
    } catch(err) {
      console.error(err);
      alert('Something went wrong. Try another photo.');
    }
    document.getElementById('processBtn').disabled = false;
  }, 60);
});

function generateSketch() {
  const img = originalImage;
  const MAX = 1400;
  let sw = img.naturalWidth, sh = img.naturalHeight;
  if (sw > MAX || sh > MAX) {
    const sc = Math.min(MAX/sw, MAX/sh);
    sw = Math.round(sw * sc); sh = Math.round(sh * sc);
  }

  const wc = document.getElementById('workCanvas');
  wc.width = sw; wc.height = sh;
  const wctx = wc.getContext('2d');
  wctx.drawImage(img, 0, 0, sw, sh);

  // Use crop fractions on the scaled image
  const cx0 = Math.round(crop.left   * sw);
  const cy0 = Math.round(crop.top    * sh);
  const cx1 = Math.round(crop.right  * sw);
  const cy1 = Math.round(crop.bottom * sh);
  const cw  = cx1 - cx0, ch = cy1 - cy0;

  const fc = document.createElement('canvas');
  fc.width = cw; fc.height = ch;
  fc.getContext('2d').drawImage(wc, cx0, cy0, cw, ch, 0, 0, cw, ch);

  const id = fc.getContext('2d').getImageData(0, 0, cw, ch).data;

  // Grayscale
  const gray = new Float32Array(cw * ch);
  for (let i = 0; i < cw * ch; i++)
    gray[i] = 0.299*id[i*4] + 0.587*id[i*4+1] + 0.114*id[i*4+2];

  // Pencil sketch
  const br = parseInt(document.getElementById('blurRadius').value);
  const inv = new Float32Array(cw * ch);
  for (let i = 0; i < cw * ch; i++) inv[i] = 255 - gray[i];
  const blurred = gaussianBlur(inv, cw, ch, br);
  const sketch = new Float32Array(cw * ch);
  for (let i = 0; i < cw * ch; i++) {
    const ib = 255 - blurred[i];
    sketch[i] = ib < 1 ? 255 : Math.min(255, (gray[i] / ib) * 256);
  }

  // Contrast
  const gamma = parseFloat(document.getElementById('contrast').value);
  const boosted = new Float32Array(cw * ch);
  for (let i = 0; i < cw * ch; i++) boosted[i] = Math.pow(sketch[i]/255, gamma) * 255;

  // Elliptical feathered mask
  const ecx = cw*0.5, ecy = ch*0.5, erx = cw*0.46, ery = ch*0.48, ff = 0.10;
  const masked = new Float32Array(cw * ch);
  for (let y = 0; y < ch; y++) {
    for (let x = 0; x < cw; x++) {
      const i = y*cw+x;
      const dx=(x-ecx)/erx, dy=(y-ecy)/ery;
      const d = Math.sqrt(dx*dx+dy*dy);
      let a = d <= 1-ff ? 1 : d <= 1+ff*0.5 ? Math.max(0, 1-(d-(1-ff))/(ff*1.5)) : 0;
      masked[i] = boosted[i]*a + 255*(1-a);
    }
  }

  const oc = document.getElementById('outputCanvas');
  oc.width = cw; oc.height = ch;
  const octx = oc.getContext('2d');
  const od = octx.createImageData(cw, ch);
  for (let i = 0; i < cw*ch; i++) {
    const v = Math.round(masked[i]);
    od.data[i*4] = od.data[i*4+1] = od.data[i*4+2] = v;
    od.data[i*4+3] = 255;
  }
  octx.putImageData(od, 0, 0);
  return oc.toDataURL('image/jpeg', 0.95);
}

// ── BOX/GAUSSIAN BLUR ──
function gaussianBlur(src, w, h, r) {
  r = Math.max(1, Math.floor(r/2));
  let t = bH(src,w,h,r); t=bV(t,w,h,r); t=bH(t,w,h,r); t=bV(t,w,h,r); t=bH(t,w,h,r); return bV(t,w,h,r);
}
function bH(s,w,h,r) {
  const d=new Float32Array(w*h), inv=1/(2*r+1);
  for(let y=0;y<h;y++){let sum=0,row=y*w;for(let x=-r;x<=r;x++)sum+=s[row+Math.max(0,Math.min(w-1,x))];for(let x=0;x<w;x++){d[row+x]=sum*inv;sum+=s[row+Math.min(w-1,x+r+1)]-s[row+Math.max(0,x-r)];}}return d;
}
function bV(s,w,h,r) {
  const d=new Float32Array(w*h), inv=1/(2*r+1);
  for(let x=0;x<w;x++){let sum=0;for(let y=-r;y<=r;y++)sum+=s[Math.max(0,Math.min(h-1,y))*w+x];for(let y=0;y<h;y++){d[y*w+x]=sum*inv;sum+=s[Math.min(h-1,y+r+1)*w+x]-s[Math.max(0,y-r)*w+x];}}return d;
}

function showSketchResult(dataUrl) {
  const ob = document.getElementById('outputBody');
  const prog = document.getElementById('progressWrap'); if(prog) prog.remove();
  const res = document.createElement('div');
  res.id = 'sketchResult'; res.className = 'sketch-result';
  res.innerHTML = `
    <img class="sketch-img" src="${dataUrl}" alt="Sketch">
    <a class="download-btn" href="${dataUrl}" download="pawtrait_sketch.jpg">↓ Download Sketch</a>
  `;
  ob.appendChild(res);
}
</script>
</body>
</html>
